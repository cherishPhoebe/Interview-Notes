**C#中常见的集合类型有哪些？**  
集合类型表示收集数据的不同方式，例如 哈希表、队列、字典和列表。  
所有集合都直接或间接基于`ICollection<T>`或`ICollection`接口。`IList`和`IDictionary`及其泛型对应项均派生自这两个接口。  
在基于`IList`或直接基于`ICollection`的集合中，每个元素都只包含一个值。这些类型有：
- Array
- ArrayList
- List<T>
- Queue
- ConcurrentQueue<T>
- Stack
- ConcurrentStack<T>
- LinkedList<T>
- HashSet<T>

在基于`IDictionary`接口的集合中，每个元素都只包含一个键值对。这些类型包括：  
- Hashtable
- SortedList
- SortedList<TKey,TValue>
- Dictionary<TKey,TValue>
- ConcurrentDictionary<TKey,TValue>


## 一.数组（Array）
- 实现原理
  - 基于内存连续分配的固定大小内存块
  - 元素通过偏移量直接访问，时间复杂度为o(1)
- 特点
  - 长度固定，类型安全，支持索引访问
  - 内存连续分配，访问速度快
- 适用场景
  - 已知元素数量，且不需动态增删的情况
  - 对性能要求高，需要快速访问的场景
  
## 二.List<T>  
- 实现原理：基于动态数组（T[]）,容量不足时自动扩容（每次扩容为当前容量的2倍）
- 特点
  - 支持索引、排序、查找等多种
- 适用场景
  - 频繁通过索引访问元素
  - 不需要频繁从中间插入/删除的线性数据集合

## 三.LinkedList<T>  
- 实现原理：基于双向链表，每个节点包含Previous和Next指针
- 特点
  - 中间插入/删除效率高（o(1),但需要先找到位置）
  - 随机访问效率低（o(n)）
  - 内存开销大（每个元素需存储指针）
- 适用场景
  - 频繁在中间插入/删除元素（实现LRU缓存）
  - 不需要快速索引访问的场景

## 四.Queue<T>/ConcurrentQueue<T> 和 Stack<T>/ConcurrentStack<T>  
- 实现原理
  - Queue：基于循环数组，维护head和tail指针
  - Stack：基于数组或链表，维护栈顶指针
- 特点
  - Queue：先进先出（FIFO）
  - Stack：后进先出（LIFO）
  - ConcurrentXXXXX<T>: 线程安全
- 适用场景
  - Queue：任务调度（消息队列，线程池任务管理）、广度优先算法（BFS）
  - Stack：需要撤销操作的场景（浏览器历史记录）、深度优先算法（DFS）

## Dictionary<TKey,TValue>
- 实现原理：基于哈希表，使用桶（bucket[]）和拉链法（开放寻址法）解决哈希冲突
- 特点
  - 插入、删除、查找时间复杂度接近O(1)（依赖哈希函数质量）
  - 元素无序存储
  - 内存占用较高（需存储哈希桶和链表指针）
- 适用场景
  - 需通过键快速查找值的场景（如缓存，配置映射）
  - 键的唯一性需要保证

## Hashtable​  
- ​内部实现​：线程安全的哈希表（锁机制），与Dictionary类似但非泛型。
- ​时间复杂度​：与Dictionary类似，但同步操作导致性能下降。
- ​优点​：线程安全（旧版）。
- ​缺点​：性能低；类型不安全。
- ​适用场景​：多线程环境下的简单键值存储（现代代码更推荐ConcurrentDictionary）。

## HashSet​​  
- ​内部实现​：基于Dictionary<TKey, TValue>，仅存储键，值部分占位符。
- ​时间复杂度​：与Dictionary相同（O(1)平均）。
- 优点​：元素唯一性保证，无序。
- 缺点​：无法直接访问元素位置。
- 适用场景​：去重、集合运算（并集、交集等）

## SortedSet​<T>​  
- ​内部实现​：红黑树（自平衡二叉搜索树）。
- 时间复杂度​：插入/删除/查找：O(log n)
- ​优点​：元素自动排序且唯一。
- ​缺点​：内存占用较高；不支持键值对。
- ​适用场景​：需要有序唯一元素的场景（如排行榜）

## SortedList<TKey, TValue>​​  
- ​内部实现​：动态数组，按键排序，通过二分查找定位元素。
- 时间复杂度​：
  - 插入/删除：O(n)（需移动元素）
  - 查找：O(log n)
- ​优点​：内存紧凑，有序键值对。
- ​缺点​：插入/删除性能差。
- ​适用场景​：读多写少且需有序键的场景（如配置项存储）。

## SortedDictionary<TKey, TValue>  
- 特点：
  - 自动按键排序的字典；
  - 基于红黑树（自平衡二叉搜索树）。
- 实现原理：
  - 使用红黑树作为底层数据结构；
  - 查找/插入/删除操作为 O(log n)。
- 使用场景：
  - 需要有序存储键值对；
  - 需要按区间查询、范围查找的场景。  



| 类型                | 有序       | 是否可重复 | 支持索引 | 插入/删除效率   | 查找效率        | 底层结构      | 使用场景           |
| ------------------- | ---------- | ---------- | -------- | --------------- | --------------- | ------------- | ------------------ |
| Array               | 是         | 是         | 是       | 慢              | 快 (`O(1)`)     | 连续内存块    | 固定大小、频繁索引 |
| List<T>             | 是         | 是         | 是       | 慢              | 中 (`O(n)`)     | 动态数组      | 通用列表           |
| LinkedList<T>       | 否         | 是         | 否       | 快              | 慢 (`O(n)`)     | 双向链表      | 中间频繁插入/删除  |
| Queue<T>            | 按入队顺序 | 是         | 否       | 快              | 中 (`O(1)`)     | 环形数组/链表 | 排队处理           |
| Stack<T>            | 按入栈顺序 | 是         | 否       | 快              | 中 (`O(1)`)     | 动态数组      | 回溯、递归         |
| Dictionary\<TKey,V> | 否         | 否 (Key)   | 否       | 快 (`O(1)`)     | 快 (`O(1)`)     | 哈希表        | 快速键值访问       |
| SortedDictionary    | 是         | 否 (Key)   | 否       | 中 (`O(log n)`) | 中 (`O(log n)`) | 红黑树        | 有序键值存储       |
| HashSet<T>          | 否         | 否         | 否       | 快 (`O(1)`)     | 快 (`O(1)`)     | 哈希表        | 去重、集合运算     |
| SortedSet<T>        | 是         | 否         | 否       | 中 (`O(log n)`) | 中 (`O(log n)`) | 红黑树        | 有序集合，集合运算 |
